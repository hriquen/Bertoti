We see three critical differences between programming and software engineering: time, scale, and the trade-offs at play. On a software engineering project, engineers need to be more concerned with the passage of time and the eventual need for change. In a software engineering organization, we need to be more concerned about scale and efficiency, both for the software we produce as well as for the organization that is producing it. Finally, as software engineers, we are asked to make more complex decisions with higher-stakes outcomes, often based on imprecise estimates of time and growth.


Within Google, we sometimes say, “Software engineering is programming integrated over time.” Programming is certainly a significant part of software engineering: after all, programming is how you generate new software in the first place. If you accept this distinction, it also becomes clear that we might need to delineate between programming tasks (development) and software engineering tasks (development, modification, maintenance). The addition of time adds an important new dimension to programming. Cubes aren’t squares, distance isn’t velocity. Software engineering isn’t programming.

Atividade 1:
Programação é apenas uma parte da engenharia de software, como dito por funcionários do Google esta é a integração da programação ao longo do tempo, com diferenças criticas como os trade-offs necessários para que um projeto seja finalizado em um determinado tempo, para que o projeto tenha maior eficiencia. Engenharia de Software engloba decisões mais complexas com mais consequências e tarefas que vão além do desenvolvimento, como modificações e manutençõe sendo o Tempo parte integral de todo esse processo.

Programação + Tempo, escala e trade-offs = Engenharia de Software.

Trade-offs = Jogo de perde e ganha, toda escolha de um projeto tem seus lados positivos e negativos e é extremamente importante saber quais as vantagens e desvantagens de cada linguagem, buscando o melhor para cada situação.


Atividade 2:
Exemplos de Trade-offs:
* Python é uma linguagem de mais alto nível e por isso se torna mais fácil de usar, porém lenta, já o Assembly por exemplo é uma linguagem de baixo nível e, por mais que mais díficil, isso torna ela mais rápida por estar mais proximas a linguagem do computador.
* Windows tem uma interface muito mais amigável aos seus usuários e se torna mais fácil de usar, porem essas interfaces o tornam mais lento que o Linux que abre mão dessa interface em troca de uma maior estabilidade e velocidade.
* Microserviços é uma metodologia de design de aplicações, onde um aplicativo é dividido em vários microserviços independentes onde cada um é feito por um pequeno time, e tem como grande vantagem a criação de grandes softwares em pouco tempo de maneira mais eficiente. Apesar disso uma das gigantes da tecnologia, a Amazon, fugiu disso ao criar o Prime, utilizando uma metodologia Monolito, onde todo o projeto é feito como uma unidade e por mais que isso exija maiores times de programação, também tem suas vantagens como a facilidade no desenvolvimento de novas funções e integração delas no projeto já que só usa um código, além de melhor performance devido ao número de API'S rodando.

 Nenhuma dessas opções é objetivamente boa ou ruim, todas tem sua utilização em seu devido espaço e será melhor em situações diferentes.
